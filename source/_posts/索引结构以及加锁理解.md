title: 索引结构以及加锁理解
date: 2016-03-09 11:14:59
categories: 技术
tags: [MySQL,索引,性能优化,树]
toc: true
---

# 磁盘结构
计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。 内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。
磁盘的构造

![image](https://cloud.githubusercontent.com/assets/11264082/13591471/e4a5e2ac-e523-11e5-8d1b-ac72fdaede4a.png)
磁盘读写原理

磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。
访问某一具体信息，由3部分时间组成：

- 查找时间(seek time) Ts: 完成上述步骤(1)所需要的时间。这部分时间代价最高，最大可达到0.1s左右。

- 等待时间(latency time) Tl: 完成上述步骤(3)所需要的时间。由于盘片绕主轴旋转速度很快，一般为7200转/分(电脑硬盘的性能指标之一, 家用的普通硬盘的转速一般有5400rpm(笔记本)、7200rpm几种)。因此一般旋转一圈大约0.0083s。

- 传输时间(transmission time) Tt: 数据通过系统总线传送到内存的时间，一般传输一个字节(byte)大概0.02us=2\*10^(-8)s

> 磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。    
> 所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构。

<!--more-->

# Btree、B+tree、红黑树
## Btree
> 首先要强调一下，B-tree==Btree，特此说明。

相比二叉树，Btree每个节点内有多个分支，即多叉的平衡查找树。Btree与红黑树最大的不同在于，Btree节点可以有许多子女。所有的叶结点都处于相同的深度，带阴影的结点为查找字母R时要检查的结点。
如图，这是一棵Btree，一棵关键字为英语中辅音字母的B树，现在要从树种查找字母R
![image](https://cloud.githubusercontent.com/assets/11264082/13593557/3d5f9254-e537-11e5-9f3f-e4da40ab9ded.png)
一棵m阶的Btree满足以下条件：
- 每个节点至多有m棵子树

- 除根节点外，其它每个分支节点至少有m/2棵子树

- 根节点至少有两棵子树

- 所有叶节点在同一层上。Btree的叶子节点可以看成一种外部节点，不包含任何信息

- 有j个孩子的非叶节点恰好有j-1个关键码，关键码按递增次序排列

B树中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。可以按下图理解：
![image](https://cloud.githubusercontent.com/assets/11264082/13593784/72c8c94a-e539-11e5-8e91-6f645f806fcb.png)
下面，咱们来模拟下查找文件29的过程：

1. 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】

1. 此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17<29<35，因此我们找到指针p2。

1. 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】

1. 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26<29<30，因此我们找到指针p2。

1. 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】

1. 此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。
> 分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。

Btree的CRUD时间复杂度：
![image](https://cloud.githubusercontent.com/assets/11264082/13591824/49c3ba44-e527-11e5-8639-032ecdd4c00e.png)
可以看出来，Btree的所有数据都是放在不同磁盘块上的

Btree具体实战:
- 下面咱们通过一个实例来逐步讲解下。插入以下字符字母到一棵空的B 树中（非根结点关键字数小了（小于2个）就合并，大了（超过4个）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S，首先，结点空间足够，4个字母插入相同的结点中，如下图：

![image](https://cloud.githubusercontent.com/assets/11264082/13595987/7035bfe2-e54a-11e5-8bc6-fa741a053b07.png)
- 当咱们试着插入H时，结点发现空间不够，以致将其分裂成2个结点，移动中间元素G上移到新的根结点中，在实现过程中，咱们把A和C留在当前结点中，而H和N放置新的其右邻居结点中。如下图：

![image](https://cloud.githubusercontent.com/assets/11264082/13595997/7a563ea2-e54a-11e5-80da-f916a0d38f0b.png)
- 当咱们插入E,K,Q时，不需要任何分裂操作

![image](https://cloud.githubusercontent.com/assets/11264082/13596000/81d24ef0-e54a-11e5-90e8-681cb0fbcfef.png)
- 插入M需要一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中

![image](https://cloud.githubusercontent.com/assets/11264082/13596011/91d0fc5c-e54a-11e5-9fa0-7fd8ef66c020.png)
- 插入F,W,L,T不需要任何分裂操作

![image](https://cloud.githubusercontent.com/assets/11264082/13596017/9d019d3e-e54a-11e5-9d9e-ea9a10220bba.png)
- 插入Z时，最右的叶子结点空间满了，需要进行分裂操作，中间元素T上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。

![image](https://cloud.githubusercontent.com/assets/11264082/13596020/a365eb12-e54a-11e5-922c-72399fe6503c.png)
- 插入D时，导致最左边的叶子结点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P,R,X,Y陆续插入不需要任何分裂操作（别忘了，树中至多5个孩子）。

![image](https://cloud.githubusercontent.com/assets/11264082/13596023/aa9d92b8-e54a-11e5-8f2c-98ca93c5b957.png)
- 最后，当插入S时，含有N,P,Q,R的结点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括D和G节点中。这样具体插入操作的完成，下面介绍删除操作，删除操作相对于插入操作要考虑的情况多点。

![image](https://cloud.githubusercontent.com/assets/11264082/13596028/b51fc3fa-e54a-11e5-9bb6-96cb2f34d89b.png)


## B+tree
传统关系型数据库(Oracle/MySQL/PostgreSQL…)，其主要的索引结构，使用的都是B+树。更有甚者，InnoDB引擎的表数据，整个都是以B+树的组织形式存放的。下图，是一个经典的B+树组织结构图(2层B+树，每个页面的扇出为4)：
![image](https://cloud.githubusercontent.com/assets/11264082/13593934/02085ce6-e53b-11e5-934f-a5da5bd35fc5.png)
注意：
- 此B+树，以InnoDB实现的B+树结构为准；

- 此B+树，有5条用户记录，分别是1，2，3，4，5；

- B+树上层页面中的记录，存储的是下层页面中的最小值(Low Key)；

- B+树的所有数据，均存储在B+树的叶节点；

- B+树叶节点的所有页面，通过双向链表链接起来；

![image](https://cloud.githubusercontent.com/assets/11264082/13595425/27263a92-e546-11e5-80e4-59abb289d326.png)
为什么说B+tree树更适合实际应用中操作系统的文件索引和数据库索引？
- B+tree的磁盘读写代价更低

> B+tree内部节点并没有指向关键字具体信息的指针。因此其中内部节点相对Btree更小。如果把所有同一内部节点的关键字存放在同一个磁盘块中，那么磁盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。想多来说IO读写次数也就降低了。
> 举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

- B+tree查询效率更稳定

> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
> 数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。

总结
通过以上介绍，大致将B树，B+树，B\*树总结如下：
- B树：有序数组+平衡多叉树；

- B+树：有序数组链表+平衡多叉树；

- B\*树：一棵丰满的B+树。

在大规模数据存储的文件系统中，B~tree系列数据结构，起着很重要的作用，对于存储不同的数据，节点相关的信息也是有所不同，这里根据自己的理解，画的一个查找以职工号为关键字，职工号为38的记录的简单示意图。(这里假设每个物理块容纳3个索引，磁盘的I/O操作的基本单位是块（block),磁盘访问很费时，采用B+树有效的减少了访问磁盘的次数。）
![image](https://cloud.githubusercontent.com/assets/11264082/13596156/849f9fba-e54b-11e5-99d3-0792f737c688.png)

> B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。
比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。
B树比如你的例子中查，17的话，一把就得到结果了，
有很多基于频率的搜索是选用B树，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。
另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。
mysql 底层存储是用B+树实现的，知道为什么。内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了

# mysql不同存储引擎索引结构
## MyISAM索引实现
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：
![image](https://cloud.githubusercontent.com/assets/11264082/13596332/d091af52-e54c-11e5-918c-e45668aa948b.png)
MyISAM的索引方式也叫做“非聚集”的，因此对应数据也不是顺序的
## InnoDB索引实现
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。
2. 第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

![image](https://cloud.githubusercontent.com/assets/11264082/13596638/aa940b2c-e54e-11e5-967d-7411651f77b3.png)
可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

2. 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：
![image](https://cloud.githubusercontent.com/assets/11264082/13596682/eba20862-e54e-11e5-9aae-02ed6f89cac4.png)
       这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。
总结
![image](https://cloud.githubusercontent.com/assets/11264082/13596562/2badbc54-e54e-11e5-8e7e-8081badb8edf.png)
3. Myisam
> - 主键索引/非主键索引
> - 叶子节点上均带有行号，通过行号进行索引

3. Innodb
> - 主键索引(聚簇索引)，叶子节点上带有数据
> - 非主键索引(第二索引)，叶子节点上带有主键id

为什么innodb存储引擎的索引设计与myisam的实现有异？
> myisam属于堆表，数据写入一直累积(concurrent_insert参数设置为2);此时写入性能比innodb好，但是无论是主键查询还是非主键查询，都不可避免的需要二次io(除非能索引内完成字段记录返回)
> innodb属于聚簇索引组织表(主键索引即数据),由于必须保证索引有序，在写入时需要找到合适的位置进行插入，有时候还会导致二叉树调整所以写入性能比myisam要差；但是主键查找时只需要一次io即可返回数据，非主键索引查询时如果在索引内不能完成查询记录返回则需要第二次的io

# mysql InnoDB事务和锁
## MVCC：Snapshot Read vs Current Read
MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。

在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

- 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)

select \* from table where ?;
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

select \* from table where ? lock in share mode;
select \* from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。
![image](https://cloud.githubusercontent.com/assets/11264082/13623266/5a41c58c-e5e0-11e5-99e7-61883fb1bee3.png)
##一条简单SQL的加锁实现分析
在介绍完一些背景知识之后，本文接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。当然，还是从最简单的例子说起。经常有朋友发给我一个SQL，然后问我，这个SQL加什么锁？就如同下面两条简单的SQL，他们加什么锁？
- SQL1：select \* from t1 where id = 10;

- SQL2：delete from t1 where id = 10;

针对这个问题，该怎么回答？我能想象到的一个答案是：
- SQL1：不加锁。因为MySQL是使用多版本并发控制的，读不加锁。

- SQL2：对id = 10的记录加写锁 (走主键索引)。

这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？
- 前提一：id列是不是主键？

- 前提二：当前系统的隔离级别是什么？

- 前提三：id列如果不是主键，那么id列上有索引吗？

- 前提四：id列上如果有二级索引，那么这个索引是唯一索引吗？

- 前提五：两个SQL的执行计划是什么？索引扫描？全表扫描？

## 死锁原理与分析
下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：
![image](https://cloud.githubusercontent.com/assets/11264082/13623403/5f69683e-e5e1-11e5-8f6c-ad66e76bc412.png)
![image](https://cloud.githubusercontent.com/assets/11264082/13623405/628a9786-e5e1-11e5-8097-22755ecf3877.png)
上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁

第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。

结论：死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。

# 索引优化
## 选择索引的数据类型
- 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。

- 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。

- 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

FAQ
4. like不能用索引？
> 尽量减少like，但不是绝对不可用，”xxxx%” 是可以用到索引的，
> 除了like，以下操作符也可用到索引：
> <，<=，=，>，>=，BETWEEN，IN
> <>，not in ，！=则不行

4. 什么样的字段不适合建索引？
> 一般来说，列的值唯一性太小（如性别，类型什么的），不适合建索引（怎样叫太小？一半说来，同值的数据超过表的百分之15，那就没必要建索引了）
> 太长的列，可以选择只建立部分索引，（如：只取前十位做索引）
> 更新非常频繁的数据不适宜建索引（怎样叫非常？意会）

4. 一次查询能用多个索引吗?
> 不能

4. 多列查询该如何建索引?
> 一次查询只能用到一个索引，所以 首先枪毙 a，b各建索引方案
> a还是b？ 谁的区分度更高（同值的最少），建谁！
> 当然，联合索引也是个不错的方案，ab，还是ba，则同上，区分度高者，在前

4. 联合索引的问题?
> where a = “xxx” 可以使用 AB 联合索引
> where b = “xxx” 则不可 （再想象一下，这是书的目录？）
> 所以，大多数情况下，有AB索引了，就可以不用在去建一个A索引了

4. 哪些常见情况不能用索引?
> like “%xxx”
> not in ， ！=
> 对列进行函数运算的情况（如 where md5(password) = “xxxx”）
> WHERE index=1 OR A=10
> 存了数值的字符串类型字段（如手机号），查询时记得不要丢掉值的引号，否则无法用到该字段相关索引，反之则没关系
也即
> select \* from test where mobile = 13711112222;
> 可是无法用到mobile字段的索引的哦（如果mobile是char 或 varchar类型的话）
> btw，千万不要尝试用int来存手机号（为什么？自己想！要不自己试试）

4. NULL 的问题
> NULL会导致索引形同虚设，所以在设计表结构时应避免NULL 的存在（用其他方式表达你想表达的NULL，比如 -1？）

4. 如何查看索引信息，如何分析是否正确用到索引?
> show index from tablename;
> explain select ……;
> 关于explain，改天可以找个时间专门写一篇入门帖，在此之前，可以尝试 google
